# Agentic Patterns

The **agentic_patterns** folder explores a variety of common design patterns for building agents with the OpenAI SDK. Each script in this folder demonstrates a specific pattern or use-case, helping developers understand higher-level strategies for agent design beyond basic examples.

-   **agent_as_tool.py** – Demonstrates the “agent as a tool” pattern (nested agents) in a concise script. This is similar in concept to the example in the `Agent_as_tool` folder, but provided here as part of the patterns collection. It sets up one agent to be used by another, illustrating modular task delegation. This script is useful to quickly see how to register and call an agent-tool without the notebook or images.
    
-   **deterministic.py** – Shows how to structure an agent for deterministic behavior. In this example, the agent might be configured with zero randomness (e.g., temperature=0) and a fixed workflow so that it produces the same output given the same input every time. It could illustrate a linear script-like chain of prompts, demonstrating how to enforce consistency and predictability in agent responses (useful for testing or procedural tasks).
    
-   **handoff_routing.py** – An example of a triage or routing agent pattern. This script likely implements an agent whose job is to decide where to route a user’s query. For example, it might examine the query and then delegate to one of several specialized agents or tools. It’s a pattern useful for building systems that need to direct requests (like routing a customer question to the right department’s agent). The code will show how the routing decision is made and how the chosen agent is invoked.
    
-   **llm_as_judge.py** – This pattern involves using an LLM agent as a judge or evaluator for other outputs. In the script, the agent could be given multiple answers or options (perhaps generated by different approaches or agents) and then decide which one is best or provide a critique. This simulates scenarios like evaluation, validation, or consensus-building between agents. It demonstrates how an agent can be used not just to generate answers, but to assess and choose between answers.
    
-   **parallelization.py** – Explores running multiple operations in parallel using agents. The script might fire off multiple agent tasks simultaneously (for example, solving different parts of a problem at once or querying multiple sources) and then combine the results. It demonstrates how to manage asynchronous or parallel agent calls, which can speed up processing when tasks can be done concurrently. This pattern is useful for performance optimization and is a bit more advanced in terms of coordinating multiple agent threads of work.
    

In addition to these scripts, this folder contains a subfolder for a specialized set of patterns:

-   **forcing_tool_use/** – A subfolder with examples focusing on forcing or controlling how an agent uses tools. (See the **Forcing Tool Use** README within that folder for details on its contents.)
    

By going through the scripts in _agentic_patterns_, you’ll gain insight into architecting agents for various scenarios like delegation, evaluation, and parallel processing. These patterns can serve as templates or inspiration for building more complex agent-based applications.